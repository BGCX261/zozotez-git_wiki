#summary The EBF-macroes that supports the datastructures
#labels Phase-Design
= Library of EBF-macroes as the core building blocks =
Previously I wrote about [MemoryDesign the memory design] of Zozotez. The Design of how to arrange memory in BF is a very important matter since there is not support for objects by default. Every data structure other than fixed place cells has to be emulated. With the power of EBF comes macroes with entry-address which is known by the compiler. Thus {{{ $a>>>&copy_a }}} and the definition {{{ {copy_a $a(-^0+^1+)^1(-$a+)} }}} will work on many places in the source without having to create specific macroes.This is what I have done with my functions.

I have defined stack and program stack functions: &stack_push , &stack_pop, &pc_push, &pc_pop which retrieves or pushes to the area in which the macro was called. This means I can get stack contents to any fo my ax-fx register.

I have defined symbol macroes. &sym_open, whichuses the current location as index. &sym_close (which does not take any argument) and &sym_get_<name> and &sym_set_<name> for each of the parameters string_ref, assoc_ref and param_list.

I have defined similar list macros using lis as prefix. &lis_open, &lis_close, &lis_get_<name> and &lis_set_<name>. 

All of these are higher order that uses lower order macroes. And these are perfect buildingblocks for implementing primitive lisp operations. (set-car $bx (car $ax)) can be done like this:

{{{
  $ax &lis_open
  $ax = &lis_get_car
  &lis_close
  $bx &lis_open
  $ax &lis_set_car
}}}
